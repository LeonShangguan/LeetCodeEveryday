# https://leetcode.com/problems/contains-duplicate/

# Python Version
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        nums.sort();
        for i in range(len(nums)-1):
            if(nums[i]==nums[i+1]):
                return True;
        return False;

# Java Version
class Solution {
    public boolean containsDuplicate(int[] nums) {
        for(int i=0; i<nums.length; i++){
            for(int j=i+1; j<nums.length; j++){
                if(nums[i]==nums[j]){
                    return true;
                }
            }
        }
        return false;
    }
}



# https://leetcode.com/problems/rotate-array/submissions/

# Java Version
class Solution {
    public void rotateOne(int[] nums){
        int tmp=nums[nums.length-1];
        for(int i=nums.length-1; i>0; i--){
            nums[i]=nums[i-1];
        }
        nums[0]=tmp;
    }
    
    public void rotate(int[] nums, int k) {
        if(nums.length!=1){
            for(int i=0; i<k; i++){
                rotateOne(nums);
            }
        }
    }
}

# Python Version
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        k=k % len(nums)
        tmp = []
        for i in range(len(nums)-k):
            tmp.append(nums[i])
        for i in range(0, k):
            nums[i] = nums[i-k+len(nums)]
        for i in range(k, len(nums)):
            nums[i] = tmp[i-k]
        
        




